%% 
%% ACS project dissertation template. 
%% 
%% Currently designed for printing two-sided, but if you prefer to 
%% print single-sided just remove ",twoside,openright" from the 
%% \documentclass[] line below. 
%%
%%
%%   SMH, May 2010. 


\documentclass[a4paper,12pt,twoside,openright]{report}


%%
%% EDIT THE BELOW TO CUSTOMIZE
%%

\def\authorname{Zongzhe Yuan\xspace}
\def\authorcollege{Christ's College\xspace}
\def\authoremail{zy272@cl.cam.ac.uk}
\def\dissertationtitle{Extending CAS with Algebraic Reductions}
\def\wordcount{14,235}


\usepackage{epsfig,graphicx,parskip,setspace,tabularx,xspace} 
\usepackage{a4wide,parskip,times}
\usepackage{a4wide,parskip}
\usepackage{amsmath}
\usepackage{nicefrac}
\usepackage{ amssymb }
\usepackage{mleftright}

%% START OF DOCUMENT
\begin{document}


%% FRONTMATTER (TITLE PAGE, DECLARATION, ABSTRACT, ETC) 
\pagestyle{empty}
\singlespacing
\input{titlepage}
\onehalfspacing
\input{declaration}
\singlespacing
\input{abstract}

\pagenumbering{roman}
\setcounter{page}{0}
\pagestyle{plain}
\tableofcontents
\listoffigures
\listoftables

\onehalfspacing

%% START OF MAIN TEXT 

\chapter{Introduction}
\pagenumbering{arabic} 
\setcounter{page}{1} 

%This is the introduction where you should introduce your work.  In
%general the thing to aim for here is to describe a little bit of the
%context for your work --- why did you do it (motivation), what was the
%hoped-for outcome (aims) --- as well as trying to give a brief
%overview of what you actually did.
%
%It's often useful to bring forward some ``highlights'' into 
%this chapter (e.g.\ some particularly compelling results, or 
%a particularly interesting finding). 
%
%It's also traditional to give an outline of the rest of the
%document, although without care this can appear formulaic 
%and tedious. Your call. 

\section{Introduction to the Path Problem and Algebraic Solution}


The path problem has always fascinated mathematicians and computer scientists. 
At the very beginning, programmer and scientists designed algorithms to solve each of the path problem. 
The most famous path problem is the shortest distance problem and there are several well-known algorithm that can solve such a problem: Dijkstra's algorithm, Bellman–Ford algorithm, A* search algorithm and Floyd–Warshall algorithm. People use different primitive metrics and various complicated algorithms to solve different path problems.\\\\
However, such an approach has its obvious shortcomings. Even at some point, designing a new algorithm can "steal" the ideas of the original algorithm, people must design a completely new independent algorithm in the face of each new problem (new metric), and this makes it difficult to have a generic (or framework) approach to solve this type of problem.  Even if the path problem has minor changes to the problem, it is difficult for people to solve the new problem by slightly modifying existing algorithms. \\
Hence, lots of predecessors have found the algebraic approaches to work around this kind of problem. 
Using the knowledge of abstract algebra, people find that the routing problem (path problem) can be represent using a data structure called "semiring" $(S,\oplus,\otimes,\bar{0},\bar{1})$\cite{carre_algebra_1971,WONGSEELASHOTE197955,dynerowicz_forwarding_2013,mohri_semiring_2002,gurney_lexicographic_2007}. For example, the popular "shortest path problem" can be represented as $(S, min,+,\infty,0)$\cite{mohri_semiring_2002} and the "maximal capacity path problem" can be represented as $(S, max,min, 0, \infty)$. \\\\
For each path problem that represented as a semiring, we can construct a corresponding matrix semiring that represent the concrete problem (the edges and the distances for the shortest path problem for example). Then using matrix multiplication and stability of the closure (the semiring), we can solve the real problem of each concrete path problem. However, the simple matrix approach can only solve the "trivial" path problem. Those complicated problem, for example the widest shortest path problem that constructed from the shortest path problem semiring and the widest path problem (maximal capacity path problem) semiring using lexicograhpic product, can't be solved by this "traditional" theory approach. Some times even the method can find an optimal solution, there is no guarantee to find all optimal solutions using the classical method.\\\\
Therefore, people have found a non-classical theory of algebraic path finding method, so that algebras that violated the distribution law can be accepted. This non-classical theory can handle the problem the simple classical theory can't handle, such as the problem that can't be solved by Dijkstra or Bellman-Ford.
This kind of method is dedicated to finding the local optimal solution at first, and then the local optimal solution is exactly the same as the global optimal solution by some verification or some addition restriction on the computation. For example, the famous protocol, the routing information protocol which is based on distributed Bellman-Ford algorithms is one of the non-traditional theory.\\\\
However, even so, RIP will also have a series of problems. For example, when a node does not have edges connected to it, the RIP matrix calculation (without pre-setting the maximum number of calculation steps) will continue infinitely. Even if the maximum number of calculation steps is set in advance, RIP still has some deficiencies in efficiency. \\\\
So while we use another protocol BGP (Border Gateway Protocol), we add an annihilator to the entire complex semiring.  At the same time, we found that when we represent the path, we may have a loop path (a node in the path has been passed more than once). So we need our problem set to change from the original path to elementary path (A path p is elementary if no node is repeated). In this process, we performed two operations $S \rightarrow S$, and here we call it reduction in general, which comes to the main problem of our project.\\\\

\section{Reduction}
Algebraic reduction, introduced by Ahnont Wongseelashote in 1977\cite{WONGSEELASHOTE197955} is an unary operator for a given set of problem, $reduce : S \longrightarrow S$. It has several properties, satisfying $reduce(\emptyset) = \emptyset$, $\forall A \in S, reduce(reduce(A)) = reduce(A)$ (which is called idempotent property) and $\oplus : S \times S \rightarrow S, \forall A,B \in S, reduce(reduce(A)\oplus B) = reduce(A\oplus B) = reduce(A\oplus reduce(B))$ (which is left and right invariant property) and this paper will discuss these properties in the later section.\\ 
It is hard to specify the reduced problem set in the most programming language. However, in the world of logic and those programming language that can be used to prove properties, programmer can represent the reduced problem set as $\{x | x \in S, reduce(x) = x\}$ which is also a subset of the original problem set. The idea to represent the reduced set explicitly is to form a pair $<x,Pr(x)>$ where $x \in S$ is the element in the set and $Pr(x) : r(x) = x$ is the proof that the element is in the subset (the element will not change after the reduced function, otherwise it will be reduced). \\
The first example of the reduction is $id$ which maps all the stuff to itself. Another example is the min-set where $min_\leq(x) = \{x \in S | \forall y \in S, \neg(y < x)\}$. Regarding to $\mathcal{P}(S)$ it works well with $\cup$ that the min-set contain all the elements and remove the element that is non-trivial set. And this reduction is used in the construction of elementary path. 


\section{Motivation}
Wongseelashote defined the reduction operator in his paper\cite{WONGSEELASHOTE197955}. However the definition there is not constructive and it is the traditional reduction.
Gurney and L11 claimed reductions could be used for "non-traditional" reductions such as elementary paths and combining elementary paths with lexicographic product \cite{gurney_construction_2010}. 
However, Gurney and L11 never worked out the details, and the reduction there is still not constructive. \\\\

It is worth mentioning that, the algebraic approaches that using the matrix as the computation rely on the property of the operators a lot, for example, the left and right distributivity of the semiring.
However, most of the cases mentioned above are aimed at some simple problems, or the ideal situations. 
In reality, we need to face the problem that, in the most time for the complex path problem (especially for lexicographic product). 
The CAS system can derive most of the properties for the new semirings from the original "simple" simirings. 
However, sometimes the problem set is not the original problem set the provided to us, but the subset of it. As I mentioned before, as the problem that consist of the lexicographic product of the shortest path problem semiring and the maximum capacity semiring, there exists some path that have 0 capacity which shouldn't be concerned in the solution of the problem. This kind of reduction can be represent as a unary operation on the original problem set in our paper.\\\\
Another example, when we are doing path problems, for the most time the path that has negative value or have infinite value is not quite interesting. However, the operation we defined there is on the whole families of object. When we are defining some data structure, like semiring, we want to know that the properties (like commutative, selective and etc..) of the proper subset (the set of objects after reduction) will hold or not, or for some cases we can't do further calculation.\\\\
As the method mentioned previously, the algebraic approach to the path problem is depend on the properties of semirings. If one, or some of the properties don't hold for the semiring, the algebraic approach can't guarantee to find the optimal solution (depends on the semiring structure and the operations). Thus, after we applying those reductions on the original problem set, there is no guarantee that the original properties will still hold for the new subset of problem set, and it comes to our point. The existing CAS system doesn't have the functionality to derive and prove the properties for the reduced problem. Hence, I want to figure out the relationship between the reduction and those properties for those operators on the problem set.\\\\
Furthermore, in most programming languages, it is extremely difficult to express the reduction properly, on contrast, we can represent the reduction as a proof or proposition in our proof world. The second goal to the project is to figure out the friendly-extraction to those reduction. 



\chapter{Background} 

%A more extensive coverage of what's required to understand your 
%work. In general you should assume the reader has a good undergraduate 
%degree in computer science, but is not necessarily an expert in 
%the particular area you've been working on. Hence this chapter 
%may need to summarize some ``text book'' material. 
%
%This is not something you'd normally require in an academic paper, 
%and it may not be appropriate for your particular circumstances. 
%Indeed, in some cases it's possible to cover all of the ``background'' 
%material either in the introduction or at appropriate places in 
%the rest of the dissertation. 

This chapter will introduce several basic concept, and some related ideas that will help us to understand the main idea of the project.

\section{Basic Definition}
In the world of logic, we need to define several basic concepts before we are really getting started.\\
We can simply understand that a Type is a collection of terms which have the same "properties". \\
Under a Type $S$, we can define a binary relationship  (in most cases we will define the binary relationship of equality $=_S$ at first).
In mathematics, A binary relation $R$ in an arbitrary Type $S$ (here I restrict the relationship to be inside a single Type, or say the element from the same type) is a collection of ordered pairs of elements of set (type) $S$, which is a subset of the Cartesian product $S \times S$. \\
In order to link the mathematical concept with the proposition in logic, I provides each relation a representation (hold or not) as a boolean value, which is regarded as a property in $Coq$. \\
$\Lambda S. brel : S \rightarrow S \rightarrow bool$. \\
Next we should define the operators that exist on a given Type:\\
binary operation $: \Lambda S.binary\_op :S \rightarrow S \rightarrow S$\\
unary operation $: \Lambda S.unary\_op:S \rightarrow S$. \\
\subsection{Properties for the Relationship}
For our definition of binary relationship, we need to focus on a few properties related to it.\\
Here we have four properties for a binary relationship for type $S$. As it is mentioned in the previous section, in order to define the proposition in the logic proof, the binary relationship will return a boolean value indicating that the relationship is holding or not, here we provide a arbitrary type variable $S$.\\
Then for a given relationship $=_S : S \rightarrow S \rightarrow bool$, we should define:\\
reflexivity: $\forall a \in S, a =_S a \equiv true$,\\
symmetric : $\forall a, b \in S, a =_S b \equiv b =_S a$, \\
transitivity: $\forall a,b,c \in S, a =_S b \equiv true \wedge b =_S c \equiv true \rightarrow a =_S c \equiv true$, \\
congruence : $\forall a,b,c,d \in S, a =_S b \equiv true \rightarrow c =_S d \equiv true \rightarrow a =_S c \equiv b = _S d$
\subsection{Properties for the Operator}
Next we need to discuss some of the properties of the unary operator and the binary operator that we have defined.
\subsubsection{Properties for Unary Operator}
For the unary operator we have defined, we want it to have the following properties, or we will analyse the unary operator we have defined from the following perspectives. \\
In fact, our unary operator is used to represent reduction, so our discussion of the properties of the unary operator is actually a discussion of some of the properties of reduction.\\
There are six properties that we need to be discussed. Three of them are of the same properties as the reduction mentioned in the previous section, here we give a arbitrary type variable $S$, a binary relationship in $S$ : $=_S$ and our unary operation $u_S$.\\
congruence : $\forall a,b \in S, a =_S b \rightarrow u_S(a) =_S u_S(b)$,\\
idempotent : $\forall a \in S, u_S(u_S(a)) =_S u_S(a)$,\\
left\_invariant: $\Lambda \oplus _S: S \rightarrow S \rightarrow S, \forall a,b \in S, u_S (a) \oplus_S b =_S a \oplus_S b$,\\
right\_invariant: $\Lambda \oplus _S: S \rightarrow S \rightarrow S, \forall a,b \in S, a \oplus_S u_S(b) =_S a \oplus_S b$,\\
preserve\_id : $\forall i \in S$, if $i$ is the identity for type $S$, equality $=_S$ and a binary operator $\oplus_S$, ($\forall a \in S, a \oplus_S i =_S a =_S i \oplus_S a$) then $u_S (i) =_S i$,\\
preserve\_annihilator : $\forall a \in S$, if $i$ is the annihilator for type $S$, equality $=_S$ and a binary operator $\oplus_S$, ($\forall b \in S, a \oplus_S b=_S a =_S b \oplus_S a$) then $u_S (b) =_S b$.



\subsubsection{Properties for Binary Operator}
Also for the binary operator we have defined, we hope that we will focus on the following six properties of it.
For a given type variable $S$, the binary relationship $=_S$ and our pre-defined binary operator $\oplus_S: S\times S \rightarrow S$, we have:\\
congruence: $\forall s_1,s_2,t_1,t_2 \in S, s_1 \equiv t_1 \wedge s_2 \equiv t_2 \rightarrow s_1 \oplus_S s_2 \equiv t_1 \oplus_S t_2$,\\
associativity: $\forall a,b,c \in S, a \oplus_S (b \oplus_S c) \equiv (a \oplus_S b) \oplus_S c$,\\
commutativity: $\forall a,b\in S, a \oplus_S b = b \oplus_S a$,\\
selectivity: $\forall a,b\in S, a \oplus_S b \in \{a,b\}$,\\
hasId: $\exists \bar0 \in S, \forall a \in S, a \oplus_S \bar0 = a = \bar0 \oplus_S a$,which means $\bar0$ is the identity for type $S$, equality $=_S$ and the binary operator $\oplus_S$,\\
hasAnn: $\exists \bar1 \in S, \forall a \in S, a \oplus_S \bar1 = \bar1 = \bar1 \oplus_S a$, which means $\bar1$ is the identity for type $S$, equality $=_S$ and the binary operator $\oplus_S$,\\
In this paper, we will mostly concentrate on those properties that are holding or not in the reduced set of problem. 


\section{Direct Product and its Properties}
Here we need to mention Product Type and some properties about Product Type. \\
CAS will use pair to combine two semirings (or just semigroups) to form a new data structure. 
Therefore we must discuss the relationship between the properties of the single semirings and the properties they have been combined with. \\
First, as with a given Type and its binary relationship, we need to define a binary relationship to describe the relationship between product type terms.\\
$\Lambda S, T, =_s, =_t. brel\_product : S * T \rightarrow S * T \rightarrow bool$, \\
$:= \lambda (s_1,t_1) (s_2, t_2). s_1 =_s s_2 \wedge t_1 =_t t_2$, (we can write this binary relationship as $=_S \times =_T$).\\
At the same time, we should give an expansion on existing unary operators and binary operators for product.\\
For two given type $S$ and $T$, unary operators $u_S$ and $u_T$, binary operators $\oplus_S$ and $\oplus_T$:\\
uop\_product: $S*T \rightarrow S*T := \lambda (s,t), (u_S (s),u_T(t))$,\\
bop\_product: $S*T \rightarrow S*T \rightarrow S*T := \lambda (s_1,t_1)(s_2,t_2), (s_1 \oplus_S s_2,t_1 \oplus_T t_2)$, (we can write this new binary operator as $(\oplus_S,\oplus_T)$).
\subsection{Properties for the Relationship}
In fact, we also focus on whether or not some of the properties of the binary relationship previously defined apply to the product type. Although the proof of this part is not the key to our project. 
Fortunately, the CAS system has systematically proved the product type properties, including binary relationship and binary operator. \\
For two given type $S$ and $T$ and their corresponding binary relationship $=_S$ and $=_T$,\\
If both $=_S$ and $=_T$ are reflexivity, then $=_S \times =_T$ is reflexivity,\\
If both $=_S$ and $=_T$ are symmetric, then $=_S \times =_T$ is symmetric,\\
If both $=_S$ and $=_T$ are transitivity, then $=_S \times =_T$ is transitivity,\\
If both $=_S$ and $=_T$ are congruence, then $=_S \times =_T$ is congruence.
\subsection{Properties for the Operator}
As mentioned above, fortunately the CAS system has given us a systematic proof of the binary operator of the product type.\\
For two given type $S$ and $T$, binary operators $\oplus_S$ and $\oplus_T$:\\
If both $\oplus_S$ and $\oplus_T$ are congruence, then $(\oplus_S,\oplus_T)$ is congruence,\\
If both $\oplus_S$ and $\oplus_T$ are commutativity, then $(\oplus_S,\oplus_T)$ is commutativity,\\
If both $\oplus_S$ and $\oplus_T$ are associativity, then $(\oplus_S,\oplus_T)$ is associativity,\\
If both $\oplus_S$ and $\oplus_T$ have Id $\bar0_S$ and $\bar0_T$, then $(\oplus_S,\oplus_T)$ has Id $(\bar0_S,\bar0_T)$,\\
If both $\oplus_S$ and $\oplus_T$ have Ann $\bar1_S$ and $\bar1_T$, then $(\oplus_S,\oplus_T)$ has Ann $(\bar1_S,\bar1_T)$.\\
It is worth mentioning that although both $\oplus_S$ and $\oplus_T$ may be selective, this does not lead to the conclusion that $(\oplus_S,\oplus_T)$ is a selective.
The explanation of selective will be mentioned later in the lexicographic product section.

\section{Semiring and its Properties}
In abstract algebra, a semiring is a data structure $(S,\oplus,\otimes,\bar0,\bar1)$ where $S$ is a set (Type) and $\oplus,\otimes$ are two operators $:S\times S \rightarrow S$.\\\\
$(S,\oplus)$ is a commutative semigroup (has associative property) and $(S,\otimes)$ is a semigroup:\\ 
$\forall a,b,c \in S, a \oplus (b\oplus c) = (a \oplus b) \oplus c$, $a \oplus b = b \oplus a$,\\
$\forall a,b,c \in S, a \otimes (b\otimes c) = (a \otimes b) \otimes c$.\\\\ 
$\oplus,\otimes$ are also left and right distributive on $S$ : \\
$\forall a,b,c \in S: a \otimes(b \oplus c) = (a \otimes b) \oplus (a \otimes c)$, \\ 
$\forall a,b,c \in S:(a \oplus b) \otimes c  = (a \otimes c) \oplus (b \otimes c)$. \\\\
$\bar0$ is the identity of $\oplus$ and  $\bar1$ is the identity of $\otimes$: \\
$\forall a \in S, a \oplus \bar{0} = a = \bar{0} \oplus a$,\\
$\forall a \in S, a \otimes \bar{1} = a = \bar{1} \otimes a$. \\\\
Finally, $\bar0$ is the  annihilator of $\otimes$: \\
$\forall a \in S, a \otimes \bar{0} = \bar{0} = \bar{0} \otimes a$.\\
Some definition will include that $\bar1$ is the annihilator of $\oplus$: \\
$\forall a \in S, a \oplus \bar{1} = \bar{1} = \bar{1} \oplus a$.


\section{Matrix Semiring and Stability}
For each semiring $(S,\oplus,\otimes,\bar0,\bar1)$ (that represent the rule of a path problem), we can define a matrix semiring $(M_n(S),\oplus,\otimes,\bar{J},\bar{I})$ to represent the concrete path problem.\\
$M_n(S)$ is a $n\times n$ matrices over $S$,\\
$(A \oplus B)(i,j) = A(i,j)\oplus B(i,j)$,\\
$(A \otimes B)(i,j) = \bigoplus_{1\leq q \leq n}A(i,q)\otimes B(q,j)$,\\
$\bar{J}(i,j) = \bar0$,\\
$\bar{I}(i,j)=\left\{
\begin{array}{rcl}
\bar1       &      & {i = j}\\
\bar0     &      & {otherwise}
\end{array} \right.$\\
So here we can easily use this matrix to encode any specific path problem and use matrix multiplication to calculate our answer. However, our calculations depend on the properties of the semiring.\\\\
$a\in S$,we define the powers $a^k$ as, $a^0 = \bar{1}$ and $a^{k+1} = a \otimes a^k$.\\
$a\in S$,we define the closure $a^*$ as, $a^{(k)} = a^0 \oplus a^1 \dots  a^k$ and $a^* = a^0 \oplus a^1 \dots  a^k \oplus \dots$.\\
Here we say, if there exists a $q$ such that $a^{q} = a^{(q+1)}$, then $a$ is q-stable, which means $a^{q} = a^*$.\\
And if we know that $S$ is 0-stable, then $M_n(S)$ is $n-1$-stable (because we can ignore paths with loops, and that is our reduction!). 
This allows us to actually calculate at most $n-1$ steps when calculating path problems.\\\\
Therefore we can define the power and closure on the matrix semiring,\\
$A\in S$,we define the powers $A^k$ as, $A^0 = \bar{I}$ and $A^{k+1} = A \otimes A^k$.\\
\section{Lexicographic Product and Distributivity}
\section{Elementary Path}


\section{Combinator for Algebraic System}
Combinator for Algebraic system (CAS)\cite{griffin_metarouting_2005} is introduced in $L11$. It is a language to design algebraic systems, in which many algebraic properties are automatically received and people can combine different operators to obtain a new semiring\cite{griffin_metarouting_2005}. We can also generalize a more complex path problem (in other words, we can abstract a more complex path problem with this new semiring, such as the lexicographic products \cite{gurney_lexicographic_2007}). CAS can easily return the properties of those combined-operation semirings and it is already defined in Coq\cite{Coq} (mentioned in $L11$ by Dr Timothy Griffin).

\chapter{Related Work} 

%This chapter covers relevant (and typically, recent) research 
%which you build upon (or improve upon). There are two complementary 
%goals for this chapter: 
%\begin{enumerate} 
%  \item to show that you know and understand the state of the art; and 
%  \item to put your work in context
%\end{enumerate} 
%
%Ideally you can tackle both together by providing a critique of
%related work, and describing what is insufficient (and how you do
%better!)
%
%The related work chapter should usually come either near the front or
%near the back of the dissertation. The advantage of the former is that
%you get to build the argument for why your work is important before
%presenting your solution(s) in later chapters; the advantage of the
%latter is that don't have to forward reference to your solution too
%much. The correct choice will depend on what you're writing up, and
%your own personal preference.

Maybe I should put this part into the background part
\section{Algebraic Apporach to the Path Problem}
\section{CAS}
\section{Semirings and Path Spaces}


\chapter{Design and Implementation} 

%This chapter may be called something else\ldots but in general 
%the idea is that you have one (or a few) ``meat'' chapters which
%describe the work you did in technical detail. 
\section{Product Theory and Product Semigroup}
\section{Reduction Properties and Reduction Theory}
Here I define the reduction in a binary operation in three different version: reduce the result of the operation, only reduce the argument of the operation and reduce both result and argument of the operation. 
$bop-reduce : \forall S:Type. \forall r: unary-op S. \forall b: binary-op S.\lambda x,y:S. r(b x y)$, 
$bop-reduce-args : \forall S:Type. \forall r: unary-op S. \forall b: binary-op S.\lambda x,y:S. b (r x) (r y)$, 
$bop-full-reduce : \forall S:Type. \forall r: unary-op S. \forall b: binary-op S.\lambda x,y:S. r(b (r x) (r y))$.

\section{Direct representation of Reduced Semigroup}
(Well defined, but not extraction friendly)\
\subsection{Homomorphism}
\section{Another Representation of Reduced Semigroup -- RSemigroup}
(Given the properties of semigroup together with the reduction proof together.)\\\\
(For those two sections, I am just thinking how to write it properly)
\section{One approach based on the Annihilator}
\chapter{Evaluation} 

For any practical projects, you should almost certainly have
some kind of evaluation, and it's often useful to separate 
this out into its own chapter. \\\\\\


\chapter{Summary and Conclusions} 

As you might imagine: summarizes the dissertation, and draws 
any conclusions. Depending on the length of your work, and 
how well you write, you may not need a summary here. 

You will generally want to draw some conclusions, and point
to potential future work. 




\appendix
\singlespacing

\bibliographystyle{unsrt} 
\bibliography{MphilProject}

\end{document}
