\section{Coq Implementation}
All the aforementioned proofs can be found in my Coq file.
In the Coq file, we directly admitted some lemmas in places where it has nothing to do with our problem (for example, the properties of lexicographic product) or the proof of the lemma is trivial true (for example, the proof of $a::as \neq as$).

In this section, we will list some key definitions and key proofs to help the reading understand the content mentioned above.

\subsection{Basic Definition}
First we need to define some basic mathematical concepts in Coq. We define the equality as a binary relationship, the unary operator and the binary operator.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition brel (S : Type)              := S → S → bool.
Definition unary_op (S : Type)          := S → S. 
Definition binary_op (S : Type)         := S → S → S. 
\end{minted}
\caption{Basic Definition} 
\label{coq:def:basic}
\end{listing}

Then we need to define the product type: direct product and lexicographic product.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition brel_product {S T : Type} (eqS : brel S) (eqT : brel T) : brel (S * T)
:= λ x y, match x, y with
          | (s1, t1), (s2, t2) => andb (eqS s1 s2) (eqT t1 t2) 
          end.
        
\end{minted}
\caption{Binary Relationship of Product Type} 
\label{coq:def:product_relationship}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition bop_product {S T : Type} (bS : binary_op S) (bT : binary_op T): binary_op (S * T) 
:= λ x y, match x, y with
          | (s1, t1), (s2, t2) => (bS s1 s2, bT t1 t2) 
          end.
\end{minted}
\caption{Direct Product of Binary Operator} 
\label{coq:def:direct_product}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition brel_complement : ∀ {S : Type}, brel S -> brel S 
:= λ {S} r x y,  if (r x y) then false else true.    
Definition brel_conjunction : ∀ {S : Type}, brel S -> brel S -> brel S 
:= λ {S} r1 r2 x y,  (r1 x y) && (r2 x y).    
Definition brel_llte : ∀ {S : Type}, brel S → binary_op S → brel S 
:= λ {S} eq b x y, eq x (b x y).    
Definition brel_llt : ∀ {S : Type}, brel S → binary_op S → brel S 
:= λ {S} eq b, brel_conjunction (brel_llte eq b) (brel_complement eq).  
Definition bop_llex : ∀ {S T : Type}, brel S → binary_op S → binary_op T → binary_op (S * T) 
:= λ {S T} eq b1 b2 x y,  
   match x, y with
    | (a, b), (c, d) => 
        (b1 a c, 
         if eq a c 
         then (b2 b d)
         else if brel_llt eq b1 a c 
              then b 
              else d)
   end.
\end{minted}
\caption{Lexicographic Product} 
\label{coq:def:lexicographic_product}
\end{listing}

Finally we need to define the method to add a constant by disjoint union.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition cas_constant : Type          := string.   
Definition brel_add_constant : ∀ {S : Type}, brel S → cas_constant → brel (cas_constant + S)
:= λ  {S} rS c x y, 
   match x, y with
   | (inl _), (inl _) => true (* all constants equal! *) 
   | (inl _), (inr _) => false 
   | (inr _), (inl _) => false 
   | (inr a), (inr b) => rS a b 
   end.

\end{minted}
\caption{Definition of Adding a Constant} 
\label{coq:def:add_const}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition bop_add_ann : ∀ {S : Type}, binary_op S → cas_constant → binary_op (cas_constant + S)
:= λ {S} bS c x y, 
   match x, y with
   | (inl _), _       => inl c
   |       _, (inl _) => inl c
   | (inr a), (inr b) => inr _ (bS a b)
   end.
   
\end{minted}
\caption{Construct Binary Operator by Adding Annihilator} 
\label{coq:def:add_const_ann}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition bop_add_id : ∀ {S : Type}, binary_op S → cas_constant → binary_op (cas_constant + S)
:= λ  {S} bS c x y, 
   match x, y with
   | (inl _), (inl _) => inl c 
   | (inl _), (inr _) => y
   | (inr _), (inl _) => x
   | (inr a), (inr b) => inr _ (bS a b)
   end.
\end{minted}
\caption{Construct Binary Operator by Adding Identity} 
\label{coq:def:add_const_ann}
\end{listing}

\subsection{Basic Properties}

Next, we define the properties that we mentioned in our previous section in Coq.

\subsubsection{Properties for Binary Relationship}
We define the properties of reflexive, symmetric, transitive and congruence for binary relationship (equality).

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition brel_reflexive (S : Type) (r : brel S) :=
  ∀ s : S, r s s = true.
Definition brel_symmetric (S : Type) (r : brel S) := 
    ∀ s t : S, (r s t = true) → (r t s = true). 
Definition brel_transitive (S : Type) (r : brel S) := 
  ∀ s t u: S, (r s t = true) → (r t u = true) → (r s u = true).
Definition brel_congruence (S : Type) (eq : brel S) (r : brel S) := 
   ∀ s t u v : S, eq s u = true → eq t v = true → r s t = r u v.
\end{minted}
\caption{Binary Relationship Property} 
\label{coq:def:brel_properties}
\end{listing}

\subsubsection{Properties for Unary Operator}
We define the properties of preserving identity/annihilator, congruence, idempotent, left/right invariant for the unary operator (reduction).

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition uop_preserves_id (S : Type) (eq : brel S) (b : binary_op S) (r : unary_op S) :=
  ∀ (s : S), bop_is_id S eq b s -> eq (r s) s = true.
Definition uop_preserves_ann (S : Type) (eq : brel S) (b : binary_op S) (r : unary_op S) :=
  ∀ (s : S), bop_is_ann S eq b s -> eq (r s) s = true.
Definition uop_congruence (S : Type) (eq : brel S) (r : unary_op S) := 
  ∀ (s1 s2 : S), eq s1 s2 = true -> eq (r s1) (r s2) = true. 
Definition uop_idempotent (S : Type) (eq : brel S) (r : unary_op S) := 
  ∀ s : S, eq (r (r s)) (r s) = true. 
Definition bop_left_uop_invariant (S : Type) (eq : brel S) (b : binary_op S) (r : unary_op S) :=
  ∀ s1 s2 : S, eq (b (r s1) s2) (b s1 s2)  = true.
Definition bop_right_uop_invariant (S : Type) (eq : brel S) (b : binary_op S) (r : unary_op S) :=
  ∀ s1 s2 : S, eq (b s1 (r s2)) (b s1 s2)  = true.
\end{minted}
\caption{Unary Operator Property} 
\label{coq:def:uop_properties}
\end{listing}

\subsubsection{Properties for Binary Operator}
We define the properties of commutative/not-commutative, congruence, selective, associative, has identity and has annihilator for our binary operator.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition bop_commutative (S : Type) (r : brel S) (b : binary_op S) 
    := ∀ s t : S, r (b s t) (b t s) = true. 
Definition bop_not_commutative(S : Type) (r : brel S) (b : binary_op S) 
  := { z : S * S & match z with (s, t) => r (b s t) (b t s) = false end }.  
Definition bop_selective (S : Type) (eq : brel S) (b : binary_op S) 
    := ∀ s t : S, (eq (b s t) s = true) + (eq (b s t) t = true).    
Definition bop_is_id (S : Type) (r : brel S) (b : binary_op S) (i : S) 
    := ∀ s : S, (r (b i s) s = true) * (r (b s i) s = true).    
Definition bop_is_ann (S : Type) (r : brel S) (b : binary_op S) (a : S)
    :=  ∀ s : S, (r (b a s) a = true) * (r (b s a) a = true).    
Definition bop_congruence (S : Type) (r : brel S) (b : binary_op S) := 
   ∀ (s1 s2 t1 t2 : S), r s1 t1 = true -> r s2 t2 = true -> r (b s1 s2) (b t1 t2) = true.
Definition bop_associative (S : Type) (r : brel S) (b : binary_op S) 
  := ∀ s t u : S, r (b (b s t) u) (b s (b t u)) = true.
\end{minted}
\caption{Basic Binary Operator Property} 
\label{coq:def:binary_properties_basic}
\end{listing}

We also define the distributive properties for two binary operators.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition bop_left_distributive (S : Type) (r : brel S) 
(add : binary_op S) (mul : binary_op S) 
   := ∀ s t u : S, r (mul s (add t u)) (add (mul s t) (mul s u)) = true. 
Definition bop_right_distributive (S : Type) (r : brel S) 
(add : binary_op S) (mul : binary_op S) 
   := ∀ s t u : S, r (mul (add t u) s) (add (mul t s) (mul u s)) = true. 
Definition bop_not_left_distributive (S : Type) (r : brel S) 
(add : binary_op S) (mul : binary_op S) 
   := {a : S * S * S & match a with (s,t,u) 
   => r (mul s (add t u)) (add (mul s t) (mul s u)) = false end}. 
Definition bop_not_right_distributive (S : Type) (r : brel S) 
(add : binary_op S) (mul : binary_op S) 
   := {a : S * S * S & match a with (s,t,u) 
   => r (mul (add t u) s) (add (mul t s) (mul u s)) = false end}.
\end{minted}
\caption{Binary Operator Distributive} 
\label{coq:def:binary_properties_distributive}
\end{listing}

Finally we define those pseudo properties (we mentioned in the previous section) to help us do reasoning on our reduction.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition bop_pseudo_associative (S : Type) (eq : brel S) (r : unary_op S) (b : binary_op S) 
  := ∀ s t u : S, eq (r (b (r (b (r s) (r t))) (r u))) (r (b (r s) (r (b (r t) (r u))))) = true.
Definition bop_pseudo_left_distributive (S : Type) (eq : brel S) (r : unary_op S) 
(add mul : binary_op S) 
  := ∀ a b c : S, 
  eq (r (mul (r a) (r (add (r b) (r c))))) 
     (r (add (r (mul (r a) (r b))) (r (mul (r a) (r c))))) = true.          
Definition bop_pseudo_right_distributive (S : Type) (eq : brel S) (r : unary_op S) 
(add mul : binary_op S) 
  := ∀ a b c : S, 
  eq (r (mul (r (add (r b) (r c))) (r a))) 
     (r (add (r (mul (r b) (r a))) (r (mul (r c) (r a))))) = true.

\end{minted}
\caption{Binary Operator Pseudo Properties} 
\label{coq:def:binary_properties_pseudo}
\end{listing}

\subsection{Construction of Semiring}
Then we need to provide a definition of semring together with its proofs. Since finally we need to construct two different versions of semiring: distributive semiring with commutative multiplicative component and non-distributive semiring with non-commutative multiplicative component semiring, which resulting of three different versions of semigroup: commutative selective semigroup, commutative semigroup and non-commutative semigroup, we need to provide separate definition for them.

First, let us define the record of proofs of the those properties for binary relationship
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record eqv_proofs (S : Type) (eq : brel S) :=
{
  eqv_reflexive      : brel_reflexive S eq            
; eqv_transitive     : brel_transitive S eq           
; eqv_symmetric      : brel_symmetric S eq
; eqv_congruence     : brel_congruence S eq eq                                      
; eqv_witness        : S                                      
}.
\end{minted}
\caption{Proof of Properties for Binary Relationship} 
\label{coq:def:eqv_proofs}
\end{listing}
Inside the record, we provide a witness which guarantee that the semiring we defined is not a trivial semiring (at least has one element, which is usually the identity or annihilator for an operator in the simiring).

Then we can define our two separate versions of semigroup. We will provide the proof of properties for the semigroup at first.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record commutative_selective_semigroup_proofs (S: Type) (eq : brel S) (b : binary_op S) := 
{
  cssg_associative   : bop_associative S eq b
; cssg_congruence    : bop_congruence S eq b
; cssg_commutative   : bop_commutative S eq b
; cssg_selective     : bop_selective S eq b                                                                            
}.
\end{minted}
\caption{Proof of Properties for Commutative Selective Semigroup} 
\label{coq:def:commutative_selective_semigroup_proofs}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record commutative_semigroup_proofs (S: Type) (eq : brel S) (b : binary_op S) := 
{
  csg_associative   : bop_associative S eq b
; csg_congruence    : bop_congruence S eq b
; csg_commutative   : bop_commutative S eq b                                      
}.
\end{minted}
\caption{Proof of Properties for Commutative Semigroup} 
\label{coq:def:commutative_semigroup_proofs}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record semigroup_proofs (S: Type) (eq : brel S) (b : binary_op S) := 
{
  sg_associative   : bop_associative S eq b
; sg_congruence    : bop_congruence S eq b
; sg_commutative_d : bop_commutative_decidable S eq b                                      
}.
\end{minted}
\caption{Proof of Properties for (None Commutative) Semigroup} 
\label{coq:def:semigroup_proofs}
\end{listing}

Then we can construct our semigroup based on these different properties records.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record commutative_selective_semigroup (S : Type) :=
{
   ceq   : brel S      
;  cbop  : binary_op S
;  ceqv  : eqv_proofs S ceq               
;  csgp  : commutative_selective_semigroup_proofs S ceq cbop
}.
\end{minted}
\caption{Commutative Selective Semigroup} 
\label{coq:def:commutative_selective_semigroup}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record commutative_semigroup (S : Type) :=
{
   ceq   : brel S      
;  cbop  : binary_op S
;  ceqv  : eqv_proofs S ceq               
;  csgp  : commutative_semigroup_proofs S ceq cbop
}.
\end{minted}
\caption{Commutative Semigroup} 
\label{coq:def:commutative_semigroup}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record semigroup (S : Type) :=
{
   eq   : brel S      
;  bop  : binary_op S
;  eqv  : eqv_proofs S eq               
;  sgp  : semigroup_proofs S eq bop
}.
\end{minted}
\caption{Semigroup} 
\label{coq:def:semigroup}
\end{listing}

Next, we will define the proof of properties for a simiring. We also provides two different versions of record, based on the distributive properties.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record dioid_proofs (S: Type) (eq : brel S) (add mul : binary_op S) (zero : S) (one : S) :=
{  
  dioid_left_distributive  : bop_left_distributive S eq add mul
; dioid_right_distributive : bop_right_distributive S eq add mul
; dioid_zero_is_add_id     : bop_is_id S eq add zero
; dioid_one_is_mul_id      : bop_is_id S eq mul one                                                      
; dioid_zero_is_mul_ann    : bop_is_ann S eq mul zero
; dioid_one_is_add_ann     : bop_is_ann S eq add one
}.
\end{minted}
\caption{Proof of Properties for Semiring} 
\label{coq:def:dioid_proofs}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record bioid_proof (S: Type) (eq : brel S) (add mul : binary_op S) (zero : S) (one : S) :=
{  
  bioid_left_distributive_decidable  : bop_left_distributive_decidable S eq add mul
; bioid_right_distributive_decidable : bop_right_distributive_decidable S eq add mul
; bioid_zero_is_add_id     : bop_is_id S eq add zero
; bioid_one_is_mul_id      : bop_is_id S eq mul one                                                      
; bioid_zero_is_mul_ann    : bop_is_ann S eq mul zero
; bioid_one_is_add_ann     : bop_is_ann S eq add one
}.
\end{minted}
\caption{Proof of Properties for Bioid (None Distributive Semiring)} 
\label{coq:def:bioid_proof}
\end{listing}

Finally, we can construct our semiring and non-distributive semiring using our previous definition.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record commutative_selective_dioid (S : Type) := {
    csdioid_eq         : brel S  
  ; csdioid_add        : binary_op S
  ; csdioid_mul        : binary_op S                                   
  ; csdioid_zero       : S
  ; csdioid_one        : S
  ; csdiode_eqv        : eqv_proofs S csdioid_eq
  ; csdiode_add_pfs    : commutative_selective_semigroup_proofs S csdioid_eq csdioid_add 
  ; csdiode_mul_pfs    : commutative_semigroup_proofs S csdioid_eq csdioid_mul 
  ; csdioid_pfs        : dioid_proofs S csdioid_eq csdioid_add csdioid_mul csdioid_zero csdioid_one
}.
\end{minted}
\caption{Commutative Selective Semiring} 
\label{coq:def:commutative_selective_dioid}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Record selective_bioid (S : Type) := {
  sbioid_eq         : brel S  
  ; sbioid_add        : binary_op S
  ; sbioid_mul        : binary_op S                                   
  ; sbioid_zero       : S
  ; sbioid_one        : S
  ; sbioid_eqv        : eqv_proofs S sbioid_eq
  ; sbioid_add_pfs    : commutative_selective_semigroup_proofs S sbioid_eq sbioid_add 
  ; sbioid_mul_pfs    : semigroup_proofs S sbioid_eq sbioid_mul 
  ; sbioid_pfs        : bioid_proof S sbioid_eq sbioid_add sbioid_mul sbioid_zero sbioid_one
}.
\end{minted}
\caption{Selective None Distributive Semiring} 
\label{coq:def:selective_bioid}
\end{listing}

\subsection{Traditional Representation of Reduction and Classical Reduction}
After that, we initially define the traditional representation of reduction.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
  Variable S : Type. 
  Variable b : binary_op S.
  Variable r : unary_op S.
  Variable eqS    : brel S.
  
  Definition Pr (x : S) := eqS (r x) x = true.  
  Definition red_Type   := { x : S & Pr x}.
  Definition red_eq : brel red_Type := λ p1 p2, eqS ((projT1 p1)) ((projT1 p2)).
  Definition red_bop : binary_op red_Type :=
    λ p1 p2,  existT Pr (bop_reduce r b (projT1 p1) (projT1 p2)) (Pr_br p1 p2).
\end{minted}
\caption{Traditional Representation of Reduction} 
\label{coq:def:traditional_representation}
\end{listing}

Then, we can do some reasoning on that representation, to prove that the equality remains all the properties that holding on the original problem set.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
  Variable refS   : brel_reflexive S eqS. 
  Variable symS   : brel_symmetric S eqS. 
  Variable transS : brel_transitive S eqS.
  Variable eqS_cong : brel_congruence S eqS eqS.
  
  Lemma red_ref : brel_reflexive red_Type red_eq. 
  Lemma red_sym : brel_symmetric red_Type red_eq. 
  Lemma red_cong : brel_congruence red_Type red_eq red_eq. 
  Lemma red_trans : brel_transitive red_Type red_eq. 
\end{minted}
\caption{Proof of Properties on Equality} 
\label{coq:proof:tr_eq}
\end{listing}

Finally we prove the properties of binary operators under traditional representation of reduction.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
  Variable b_cong : bop_congruence S eqS b. 
  Variable b_ass  : bop_associative S eqS b. 
  Variable b_sel  : bop_selective S eqS b. 
  Variable b_com  : bop_commutative S eqS b. 
  
  Variable r_cong  : uop_congruence S eqS r. 
  Variable r_idem  : uop_idempotent S eqS r. 
  Variable r_left  : bop_left_uop_invariant S eqS (bop_reduce r b) r.  
  Variable r_right : bop_right_uop_invariant S eqS (bop_reduce r b) r.
  
  Lemma red_bop_cong : bop_congruence red_Type red_eq red_bop.
  Lemma red_bop_ass : bop_associative red_Type red_eq red_bop. 
  Lemma red_bop_comm : bop_commutative red_Type red_eq red_bop. 
  Lemma red_bop_sel : bop_selective red_Type red_eq red_bop. 
  Lemma red_bop_id : uop_preserves_id S eqS b r -> 
                     bop_exists_id S eqS b -> 
                     bop_exists_id red_Type red_eq red_bop. 
  Lemma red_bop_ann : uop_preserves_ann S eqS b r -> 
                      bop_exists_ann S eqS b -> 
                      bop_exists_ann red_Type red_eq red_bop. 

\end{minted}
\caption{Proof of Properties on Binary Operator} 
\label{coq:proof:tr_bop}
\end{listing}

And we can prove the properties of distributive of two binary operators.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
  Definition T : Type := red_Type S r eq.
  Definition eqT : brel T := red_eq S r eq.
  Variable add mul : binary_op S.
  Definition addT : binary_op T := red_bop S add r eq r_idem. 
  Definition mulT : binary_op T := red_bop S mul r eq r_idem.
  
  Lemma addT_mulT_left_distributive :
    bop_left_uop_invariant S eq (bop_reduce r add) r ->
    bop_right_uop_invariant S eq (bop_reduce r add) r ->
    bop_right_uop_invariant S eq (bop_reduce r mul) r ->    
    bop_left_distributive S eq add mul -> 
    bop_left_distributive T eqT addT mulT.
  Lemma addT_mulT_right_distributive :
    bop_left_uop_invariant S eq (bop_reduce r add) r ->
    bop_right_uop_invariant S eq (bop_reduce r add) r ->
    bop_left_uop_invariant S eq (bop_reduce r mul) r ->    
    bop_right_distributive S eq add mul -> 
    bop_right_distributive T eqT addT mulT.
\end{minted}
\caption{Distributive on Binary Operators} 
\label{coq:proof:tr_distributive}
\end{listing}

Here we only list the lemma as a skeleton for what we need to prove, detailed proof could be found in Coq file.

\subsection{Generalized Representation of Reduction and Generalized Reduction}
Then we can define our generalized representation of reduction.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
  Definition brel_reduce {S : Type} (r : unary_op S) (eq : brel S) : brel S
  := λ x y,  eq (r x) (r y).   
  Definition bop_reduce {S : Type} (r : unary_op S) (b : binary_op S) : binary_op S
  := λ x y,  r (b x y).
  Definition bop_full_reduce {S : Type} (r : unary_op S) (b : binary_op S) : binary_op S
  := λ x y,  r(b (r x) (r y)).   
\end{minted}
\caption{Generalized Representation of Reduction} 
\label{coq:def:generalized_representation}
\end{listing}
In the case that the reduction is classical, bop\_reduce will equal to bop\_full\_reduce, otherwise we give a way that the reduction can only have the properties of congruence and idempotent with out left/right invariant.

Then we have a bunch of isomorphism to prove that those two representation are exactly representing the same problem set.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Lemma red_ref_iso : brel_reflexive red_Type red_eq <-> brel_reflexive S (brel_reduce r eqS).
Lemma red_sym_iso : brel_symmetric red_Type red_eq <-> brel_symmetric S (brel_reduce r eqS).
Lemma red_tran_iso : brel_transitive red_Type red_eq <-> brel_transitive S (brel_reduce r eqS).
Lemma red_brel_cong_iso : brel_congruence red_Type red_eq red_eq <-> 
                          brel_congruence S (brel_reduce r eqS) (brel_reduce r eqS).
\end{minted}
\caption{Equality Isomorphism Between Two Representation} 
\label{coq:proof:eq_iso}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Lemma red_cong_iso : bop_congruence red_Type red_eq red_bop <-> 
                     bop_congruence S (brel_reduce r eqS) (bop_full_reduce r b).
Lemma red_bop_ass_iso : bop_associative red_Type red_eq red_bop <-> 
                        bop_pseudo_associative S eqS r b. 
Lemma red_comm_iso :  bop_commutative red_Type red_eq red_bop <-> 
                      bop_commutative S (brel_reduce r eqS) (bop_full_reduce r b).
Lemma red_not_comm_iso :  bop_not_commutative red_Type red_eq red_bop <-> 
                          bop_not_commutative S (brel_reduce r eqS) (bop_full_reduce r b).
Lemma red_sel_iso :  bop_selective red_Type red_eq red_bop <-> 
                     bop_selective S (brel_reduce r eqS) (bop_full_reduce r b).
\end{minted}
\caption{Binary Operation Isomorphism Between Two Representation} 
\label{coq:proof:bop_iso}
\end{listing}

Then we define the isomorphism between the distributive properties.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Lemma red_bop_left_dist_iso : bop_left_distributive T eqT addT mulT <-> 
                              bop_left_distributive S (brel_reduce r eq) (bop_full_reduce r add) 
                                                                         (bop_full_reduce r mul).
Lemma red_bop_right_dist_iso : bop_right_distributive T eqT addT mulT <-> 
                               bop_right_distributive S (brel_reduce r eq) (bop_full_reduce r add) 
                                                                           (bop_full_reduce r mul).                                                                         
\end{minted}
\caption{Distributive Isomorphism Between Two Representation} 
\label{coq:proof:distributive_iso}
\end{listing}

Finally, we prove the isomorphism between the pseudo properties we defined, and the properties we need to prove on the binary operator.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
  Variable refS   : brel_reflexive S eqS. 
  Variable symS   : brel_symmetric S eqS. 
  Variable transS : brel_transitive S eqS.
  Variable r_cong  : uop_congruence S eqS r. 
  Variable r_idem  : uop_idempotent S eqS r.
  Variable b_cong : bop_congruence S eqS b.                                                                                                                                                    
  
  Lemma bop_full_reduce_pseudo_associative_implies_associative : 
         bop_pseudo_associative S eqS r bS -> 
         bop_associative S (brel_reduce r eqS) (bop_full_reduce r bS). 
  Lemma bop_full_reduce_associative_implies_pseudo_associative :
         bop_associative S (brel_reduce r eqS) (bop_full_reduce r bS) ->
         bop_pseudo_associative S eqS r bS. 
         
  Lemma bop_reduce_pseudo_left_distributivity_iso :
         bop_left_distributive S (brel_reduce r eq) (bop_full_reduce r add) (bop_full_reduce r mul).
         <->
         bop_pseudo_left_distributive S eq r add mul.
  Lemma bop_reduce_pseudo_right_distributivity_iso :
         bop_right_distributive S (brel_reduce r eq) (bop_full_reduce r add) (bop_full_reduce r mul).
         <->
         bop_pseudo_right_distributive S eq r add mul.
\end{minted}
\caption{Isomorphism Between Pseudo and Real Properties} 
\label{coq:proof:pseudo_iso}
\end{listing}

\subsection{Predicate Reduction}
Initially we provide a definition of the predicate, and define several properties of our predicate we've mentioned in the previous section.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition pred (S : Type)              := S → bool.
Definition pred_true (S : Type) (P : pred S) (s : S) 
  := P s = true. 
Definition pred_congruence (S : Type) (eq : brel S) (P : pred S) 
  := ∀ (a b : S), eq a b = true -> P a = P b.
Definition pred_bop_decompose (S : Type) (P : pred S) (bS : binary_op S) 
  := ∀ (a b : S), P (bS a b) = true -> (P a = true) + (P b = true).
Definition pred_bop_compose (S : Type) (P : pred S) (bS : binary_op S) 
  := ∀ (a b : S), (P a = true) + (P b = true) -> P (bS a b) = true.
Definition pred_preserve_order (S : Type) (P : pred S) (eqS : brel S) (bS : binary_op S)
  := ∀ (a b : S), eqS (bS a b) a = true -> P a = true -> P b = true.
\end{minted}
\caption{Predicate Definition and Properties} 
\label{coq:def:predicate}
\end{listing}
Then we need to define the reduction over the predicate 
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition uop_predicate_reduce : ∀ {S : Type}, S -> (S -> bool) -> unary_op S 
  := λ  {S} s1 P s2,  if P s2 then s1 else s2.
Definition bop_fpr {S : Type} (s : S ) (P : S -> bool) (bS : binary_op S) := 
  bop_full_reduce (uop_predicate_reduce s P) bS.
\end{minted}
\caption{Predicate Reduction} 
\label{coq:def:predicate_reduction}
\end{listing}
As we mentioned in the early section, predicate reduction have all the properties that belongs to generalized reduction. Therefore we only need to concern about the properties that is specific to the predicate reduction.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Lemma bop_pseudo_associative_fpr_decompositional_id :
  ∀ (c : S) (bS : binary_op S),
    pred_true S P c ->
    pred_congruence S eq P ->
    bop_congruence S eq bS ->     
    bop_associative S eq bS -> 
    pred_bop_decompose S P bS ->
    bop_is_id S eq bS c -> 
    bop_pseudo_associative S eq (uop_predicate_reduce c P) bS. 
Lemma bop_pseudo_associative_fpr_decompositional_ann :
  ∀ (s : S) (bS : binary_op S),
    pred_true S P s -> 
    pred_congruence S eq P ->
    bop_associative S eq bS ->    
    pred_bop_decompose S P bS ->
    bop_is_ann S eq bS s ->     
    bop_pseudo_associative S eq (uop_predicate_reduce s P) bS.

\end{minted}
\caption{Associative For Predicate} 
\label{coq:proof:predicate_associative}
\end{listing}
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Lemma bop_fpr_left_distributive :
  ∀ (s : S) (add mul : binary_op S),
     pred_true S P s -> 
     pred_congruence S eq P ->
     pred_bop_decompose S P add ->
     pred_bop_decompose S P mul ->          
     bop_congruence S eq add ->     
     bop_congruence S eq mul -> 
     bop_is_id S eq add s ->     
     bop_is_ann S eq mul s ->
     bop_left_distributive S eq add mul ->
     bop_left_distributive S (brel_reduce (uop_predicate_reduce s P) eq) 
                             (bop_fpr s P add) (bop_fpr s P mul).
Lemma bop_fpr_right_distributive :
  ∀ (s : S) (add mul : binary_op S),
     pred_true S P s -> 
     pred_congruence S eq P ->
     pred_bop_decompose S P add ->
     pred_bop_decompose S P mul ->          
     bop_congruence S eq add ->     
     bop_congruence S eq mul -> 
     bop_is_id S eq add s ->     
     bop_is_ann S eq mul s ->
     bop_right_distributive S eq add mul ->
     bop_right_distributive S (brel_reduce (uop_predicate_reduce s P) eq) 
                              (bop_fpr s P add) (bop_fpr s P mul).
\end{minted}
\caption{Distributive For Predicate} 
\label{coq:proof:predicate_distributive}
\end{listing}
For properties of preserving order and composition, we have proved that reduction is a classical if it has one of such properties, and we can directly prove associative/distributive properties from the classical reduction.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Lemma bop_left_uop_invariant_predicate_reduce :
  ∀ (s : S) (bS : binary_op S),
    pred_true S P s -> 
    pred_bop_compose S P bS ->
    bop_left_uop_invariant S eq (bop_reduce (uop_predicate_reduce s P) bS) 
                                (uop_predicate_reduce s P).
Lemma bop_right_uop_invariant_predicate_reduce :
  ∀ (s : S) (bS : binary_op S),
    pred_true S P s -> 
    pred_bop_compose S P bS ->    
    bop_right_uop_invariant S eq (bop_reduce (uop_predicate_reduce s P) bS) 
                                 (uop_predicate_reduce s P).
\end{minted}
\caption{Composition implies Classical} 
\label{coq:proof:composition_classic}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Lemma bop_left_uop_invariant_predicate_reduce_v2 :
  ∀ (s : S) (bS : binary_op S),
    pred_true S P s ->
    pred_congruence S eq P -> 
    bop_selective S eq bS ->
    bop_is_id S eq bS s ->        
    pred_preserve_order S P eq bS ->
    bop_left_uop_invariant S eq (bop_reduce (uop_predicate_reduce s P) bS) 
                                (uop_predicate_reduce s P).
Lemma bop_right_uop_invariant_predicate_reduce_v2 :
  ∀ (s : S) (bS : binary_op S),
    pred_true S P s ->
    pred_congruence S eq P -> 
    bop_selective S eq bS ->
    bop_commutative S eq bS ->
    bop_is_id S eq bS s ->        
    pred_preserve_order S P eq bS ->
    bop_right_uop_invariant S eq (bop_reduce (uop_predicate_reduce s P) bS) 
                                 (uop_predicate_reduce s P).
\end{minted}
\caption{Preserving Order implies Classical} 
\label{coq:proof:preserve_order_classic}
\end{listing}
Next we need to use our predicate reduction to construct three different reductions, and to define our path problem semiring.
\subsection{Min Plus With Ceiling}
Initially we provide the definition of the equality, two binary operators and the predicate for our problem.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition brel_eq_nat  : brel nat  := Arith.EqNat.beq_nat.
Definition min := Nat.min.
Definition plus := Nat.add.
Definition P (ceiling : nat): nat -> bool := λ n, ceiling <=? n.
\end{minted}
\caption{Min Plus With Ceiling Definition} 
\label{coq:def:min_plus_with_ceiling}
\end{listing}

By using the lemmas in Coq library for $min$ and $+$, we can easily get the properties of those two operators, such as commutative, associative, etc.

Then we need to discuss the properties of the predicate, and the properties between the predicate and the two binary operators.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Lemma P_congruence (ceiling : nat): pred_congruence nat brel_eq_nat (P ceiling).
Lemma P_true (ceiling : nat): pred_true nat (P ceiling) ceiling.
Lemma P_min_decompose (ceiling : nat): pred_bop_decompose nat (P ceiling) min.
Lemma P_min_preserve_order (ceiling : nat): pred_preserve_order nat (P ceiling) brel_eq_nat min.
Lemma P_plus_compose (ceiling : nat): pred_bop_compose nat (P ceiling) plus.
\end{minted}
\caption{Properties for the Predicate} 
\label{coq:proof:predicate_properties}
\end{listing}

Then we can define our reduction based on the predicate.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition uop_nat (ceiling : nat) : unary_op nat := uop_predicate_reduce ceiling (P ceiling).
Definition bop_nat_min (ceiling : nat) : binary_op nat := bop_fpr ceiling (P ceiling) min.
Definition bop_nat_plus (ceiling : nat) : binary_op nat := bop_fpr ceiling (P ceiling) plus.
\end{minted}
\caption{Min Plus With Ceiling Reduction} 
\label{coq:def:min_plus_with_ceiling_reduction}
\end{listing}

The rest of the properties can be proved using the properties defined in the predicate reduction and generalized reduction section.

Finally we can construct our semiring.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition eqv_proofs_eq_nat (ceiling : nat) : eqv_proofs nat 
(brel_reduce (uop_nat ceiling) brel_eq_nat)
:= {| 
     eqv_reflexive   := brel_reduce_nat_reflexive ceiling
   ; eqv_transitive  := brel_reduce_nat_transitive ceiling
   ; eqv_symmetric   := brel_reduce_nat_symmetric ceiling
   ; eqv_congruence  := brel_reduce_nat_congruence ceiling
   ; eqv_witness     := 0
|}. 
\end{minted}
\caption{Equality Proof} 
\label{coq:proof:eqv_proofs_eq_nat}
\end{listing}
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition min_proofs (ceiling : nat) : 
commutative_selective_semigroup_proofs nat 
(brel_reduce (uop_nat ceiling) brel_eq_nat) (bop_nat_min ceiling) 
:= {|
  cssg_associative   := bop_nat_min_associative ceiling
; cssg_congruence    := bop_nat_min_congruence ceiling
; cssg_commutative   := bop_nat_min_commutative ceiling
; cssg_selective     := bop_nat_min_selective ceiling                                         
|}.
\end{minted}
\caption{Proof for Min Operator} 
\label{coq:def:min_proofs}
\end{listing}
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition plus_proofs (ceiling : nat) : 
commutative_semigroup_proofs nat 
(brel_reduce (uop_nat ceiling) brel_eq_nat) (bop_nat_plus ceiling) 
:= {|
  csg_associative   := bop_nat_plus_associative ceiling
; csg_congruence    := bop_nat_plus_congruence ceiling
; csg_commutative    := bop_nat_plus_commutative ceiling                                                 
|}.
\end{minted}
\caption{Proof for Plus Operator} 
\label{coq:def:plus_proofs}
\end{listing}
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition min_plus_dioid_proofs (ceiling : nat) : 
dioid_proofs nat (brel_reduce (uop_nat ceiling) brel_eq_nat) 
(bop_nat_min ceiling) (bop_nat_plus ceiling) ceiling  0 
:= {|  
  dioid_left_distributive  := bop_left_distributive_ceiling_min_plus ceiling
; dioid_right_distributive := bop_right_distributive_ceiling_min_plus ceiling
; dioid_zero_is_add_id     := bop_is_id_ceiling_min_ceiling ceiling 
; dioid_one_is_mul_id      := bop_is_id_ceiling_plus_zero ceiling 
; dioid_one_is_add_ann     := bop_is_ann_ceiling_min_zero ceiling    
; dioid_zero_is_mul_ann    := bop_is_ann_ceiling_plus_ceiling ceiling 
|}.
\end{minted}
\caption{Proof for Semiring Property} 
\label{coq:def:min_plus_dioid_proofs}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition min_plus_dioid (ceiling : nat) : commutative_selective_dioid nat 
:= {|
    csdioid_eq         := brel_reduce (uop_nat ceiling) brel_eq_nat
  ; csdioid_add        := bop_nat_min ceiling
  ; csdioid_mul        := bop_nat_plus ceiling                                  
  ; csdioid_zero       := ceiling
  ; csdioid_one        := 0
  ; csdiode_eqv        := eqv_proofs_eq_nat ceiling
  ; csdiode_add_pfs    := min_proofs ceiling 
  ; csdiode_mul_pfs    := plus_proofs ceiling                                      
  ; csdioid_pfs        := min_plus_dioid_proofs ceiling 
|}.
\end{minted}
\caption{Min Plus With Ceiling Semiring} 
\label{coq:def:min_plus_dioid}
\end{listing}

\subsection{Elementary Path}
Initially we provide the definition of the equality, two operators and the predicate. 

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition brel_list : ∀ {S : Type}, brel S → brel(list S)
:= fix f {S} U x y := 
      match x, y with
         | nil, nil => true 
         | nil, _ => false 
         | _, nil => false 
         | a::tla, b::tlb => andb (U a b) (f U tla tlb)
      end.
Definition S := nat.
Definition eqS := Arith.EqNat.beq_nat.
Definition brel_list_S  : brel (list S) := brel_list S eqS.
Variable c : cas_constant.
Definition brel_list_const : brel (cas_constant + list S ) 
:= brel_add_constant brel_list_S c. 
Definition T := cas_constant + list S.
\end{minted}
\caption{Elementary Path Equality} 
\label{coq:def:elementary_path_eq}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Fixpoint dic_order (l1 l2 : list S) : bool :=
match l1,l2 with
| nil,_ => true
| _,nil => false    
| x::xl, y :: yl => if eqS x y
                    then dic_order xl yl
                    else x <? y 
end.
Definition minS : binary_op (list S) :=
  λ l1 l2, if length l1 =? length l2
           then dic_minS l1 l2 
           else left_shortest l1 l2.
Definition minT := bop_add_id minS c.
\end{minted}
\caption{Elementary Path Additive Component} 
\label{coq:def:elementary_path_min}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition app := List.app.
Definition appS := app S.
Definition appT := bop_add_ann appS c.
\end{minted}
\caption{Elementary Path Multiplicative Component} 
\label{coq:def:elementary_path_app}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Fixpoint elem_in_list  (S : Type)(eqS : brel S)(x : S)(l : list S) : bool :=
match l with
| nil => false
| y :: yl => orb (eqS x y) (elem_in_list S eqS x yl)
end.
Fixpoint dup_in_list (S : Type)(eqS : brel S)(l : list S): bool :=
match l with
| nil => false
| y :: yl =>  orb (elem_in_list S eqS y yl) (dup_in_list S eqS yl)
end.
Definition P : T -> bool :=  λ x,
match x with
| inr xl => dup_in_list S eqS xl
| inl _ => true
end.
\end{minted}
\caption{Elementary Path Predicate} 
\label{coq:def:elementary_path_predicate}
\end{listing}

We also reasoning the properties for the additive component that it has the properties of associative, congruence, selective and commutative.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Lemma bop_list_minT_commutative : bop_commutative T brel_list_const minT.
Lemma bop_list_minT_selective : bop_selective T brel_list_const minT.
Lemma bop_list_minT_associative : bop_associative T brel_list_const minT.
Lemma bop_list_minT_congruence : bop_congruence T brel_list_const minT.
\end{minted}
\caption{Properties for Min} 
\label{coq:proof:elementary_path_min}
\end{listing}
By using the lemmas in Coq library for $app$, we can easily get the properties of the multiplicative component.

Then we need to discuss the properties of the predicate, and the properties between the predicate and the two binary operators.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Lemma P_true : pred_true T P (inl c).
Lemma P_congruence : pred_congruence T brel_list_const P.
Lemma P_min_decompose : pred_bop_decompose T P minT.
Lemma P_app_compose : pred_bop_compose T P appT.
\end{minted}
\caption{Properties for the Predicate} 
\label{coq:proof:predicate_properties}
\end{listing}

Then based on the predicate we can define our reduction.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition uop_list : unary_op T := uop_predicate_reduce (inl c) P.
Definition bop_list_app : binary_op T := bop_fpr (inl c) P appT.
Definition bop_list_min : binary_op T := bop_fpr (inl c) P minT.
\end{minted}
\caption{Elementary Path Reduction} 
\label{coq:def:elementary_path_reduction}
\end{listing}

The rest of the properties can be proved using the properties defined in the predicate reduction and generalized reduction section (not commutative for multiplicative component, and not distributive on both operator).

Finally we can construct our semiring.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition eqv_proofs_eq_T : eqv_proofs T (brel_reduce uop_list brel_list_const)
:= {| 
     eqv_reflexive   := brel_reduce_list_const_reflexive
   ; eqv_transitive  := brel_reduce_list_const_transitive
   ; eqv_symmetric   := brel_reduce_list_const_symmetric
   ; eqv_congruence  := brel_reduce_list_const_congruence
   ; eqv_witness     := (inl c)
|}.  
\end{minted}
\caption{Equality Proof} 
\label{coq:proof:eqv_proofs_eq_T}
\end{listing}
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition min_proofs  : 
commutative_selective_semigroup_proofs T 
(brel_reduce uop_list brel_list_const) bop_list_min
:= {|
  cssg_associative   := bop_list_min_associative
; cssg_congruence    := bop_list_min_congruence
; cssg_commutative   := bop_list_min_commutative
; cssg_selective     := bop_list_min_selective                                        
|}.
\end{minted}
\caption{Proof for Min Operator} 
\label{coq:def:min_proofs}
\end{listing}
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition app_proofs: 
semigroup_proofs T (brel_reduce uop_list brel_list_const) bop_list_app
:= {|
  sg_associative   := bop_list_app_associative
; sg_congruence    := bop_list_app_congruence
; sg_commutative_d    := bop_list_app_commutative_decidable                                                
|}.
\end{minted}
\caption{Proof for Plus Operator} 
\label{coq:def:app_proofs}
\end{listing}
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition min_app_non_distributive_dioid_proofs : 
bioid_proof T (brel_reduce uop_list brel_list_const) 
bop_list_min bop_list_app (inl c) (inr nil)
:= {|  
  bioid_left_distributive_decidable := bop_left_distributive_min_app_decidable
; bioid_right_distributive_decidable := bop_right_distributive_min_app_decidable
; bioid_zero_is_add_id     := bop_is_id_min
; bioid_one_is_mul_id      := bop_is_id_app 
; bioid_zero_is_mul_ann     := bop_is_ann_app
; bioid_one_is_add_ann    := bop_is_ann_min
|}.
\end{minted}
\caption{Proof for None Distributive Semiring Property} 
\label{coq:def:min_app_non_distributive_dioid_proofs}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition min_app_non_distributive_dioid : selective_bioid T
:= {|
    sbioid_eq         := brel_reduce uop_list brel_list_const
  ; sbioid_add        := bop_list_min
  ; sbioid_mul        := bop_list_app                                 
  ; sbioid_zero       := inl c
  ; sbioid_one        := inr nil
  ; sbioid_eqv        := eqv_proofs_eq_T
  ; sbioid_add_pfs    := min_proofs
  ; sbioid_mul_pfs    := app_proofs
  ; sbioid_pfs        := min_app_non_distributive_dioid_proofs
|}.
\end{minted}
\caption{Elementary Path Semiring} 
\label{coq:def:min_app_non_distributive_dioid}
\end{listing}
\subsection{Final Path Problem}
Finally we construct our final Path problem semiring by using the lexicographic product we defined previously.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Variable ceiling : nat.
Variable c : cas_constant.
Definition T := cas_constant + list nat.
Definition min_plus_ceiling_dioid := min_plus_dioid ceiling.
Definition elementary_path_bioid := min_app_non_distributive_dioid c.
Definition add1 := csdioid_add nat min_plus_ceiling_dioid.
Definition mul1 := csdioid_mul nat min_plus_ceiling_dioid.
Definition add2 := sbioid_add T elementary_path_bioid.
Definition mul2 := sbioid_mul T elementary_path_bioid.
Definition eqN := csdioid_eq nat min_plus_ceiling_dioid.
Definition eqT := sbioid_eq T elementary_path_bioid.
Definition M := nat * T.
Definition eqM : brel M := brel_product eqN eqT.
Definition add :binary_op M := bop_llex eqN add1 add2.
Definition mul :binary_op M:= bop_product mul1 mul2.
Definition zero1 : nat := ceiling.
Definition one1  : nat := 0.
Definition zero2 : T := inl c.
Definition one2  : T := inr nil.
Definition zero  : M := (zero1,zero2).
Definition one   : M := (one1,one2).
\end{minted}
\caption{Path Problem Basic Definition} 
\label{coq:def:path_problem_basic}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition P := reduce_annihilators.P nat T eqN eqT zero1 zero2.
Lemma P_true : pred_true M P zero.
Lemma P_cong : pred_congruence M eqM P.
Lemma P_decompose_add : pred_bop_decompose M P add.
Lemma P_compose_mul : pred_bop_compose M P mul.
\end{minted}
\caption{Path Problem Predicate} 
\label{coq:def:path_problem_predicate}
\end{listing}

And we can define our reduction.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition uop_rap : unary_op M := reduce_annihilators.uop_rap nat T eqN eqT zero1 zero2.
Definition brel_eq_M :brel M := brel_reduce uop_rap eqM. 
Definition bop_rap_add : binary_op M := bop_fpr zero P add.
Definition bop_rap_mul : binary_op M := bop_fpr zero P mul.
\end{minted}
\caption{Path Problem Reduction} 
\label{coq:def:path_problem_Reduction}
\end{listing}

The rest of the properties can be proved using the properties defined in the predicate reduction and generalized reduction section (not commutative for multiplicative component, and not distributive on both operator).

Finally we can construct our path problem semiring.
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition eqv_proofs_eq_T : eqv_proofs M brel_eq_M
:= {| 
     eqv_reflexive   := brel_eq_M_reflexive
   ; eqv_transitive  := brel_eq_M_transitive
   ; eqv_symmetric   := brel_eq_M_symmetric
   ; eqv_congruence  := brel_eq_M_congruence
   ; eqv_witness     := zero
|}. 
\end{minted}
\caption{Equality Proof} 
\label{coq:proof:eqv_proofs_eq_T}
\end{listing}
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition min_proofs  : 
commutative_selective_semigroup_proofs M brel_eq_M bop_rap_add
:= {|
  cssg_associative   := bop_rap_add_associative
; cssg_congruence    := bop_rap_add_congruence
; cssg_commutative   := bop_rap_add_commutative
; cssg_selective     := bop_rap_add_selective                                       
|}.
\end{minted}
\caption{Proof for Min Operator} 
\label{coq:def:min_proofs}
\end{listing}
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition app_proofs: 
semigroup_proofs M brel_eq_M bop_rap_mul
:= {|
  sg_associative   := bop_rap_mul_associative
; sg_congruence    := bop_rap_mul_congruence
; sg_commutative_d    := bop_rap_mul_commutative_decidable                                                
|}.
\end{minted}
\caption{Proof for Plus Operator} 
\label{coq:def:app_proofs}
\end{listing}
\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition min_app_non_distributive_dioid_proofs : 
bioid_proof M brel_eq_M bop_rap_add bop_rap_mul zero one
:= {|  
bioid_left_distributive_decidable := bop_left_distributive_add_mul_decidable
; bioid_right_distributive_decidable := bop_right_distributive_add_mul_decidable
; bioid_zero_is_add_id     := bop_is_id_add_zero
; bioid_one_is_mul_id      := bop_is_id_mul_one 
; bioid_zero_is_mul_ann    := bop_is_ann_mul_zero
; bioid_one_is_add_ann     := bop_is_ann_add_one
|}.
\end{minted}
\caption{Proof for None Distributive Semiring Property} 
\label{coq:def:min_app_non_distributive_dioid_proofs}
\end{listing}

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{coq}
Definition min_app_non_distributive_dioid : selective_bioid M
:= {|
    sbioid_eq         := brel_eq_M
  ; sbioid_add        := bop_rap_add
  ; sbioid_mul        := bop_rap_mul                                 
  ; sbioid_zero       := zero
  ; sbioid_one        := one
  ; sbioid_eqv        := eqv_proofs_eq_T
  ; sbioid_add_pfs    := min_proofs
  ; sbioid_mul_pfs    := app_proofs
  ; sbioid_pfs        := min_app_non_distributive_dioid_proofs
|}.
\end{minted}
\caption{Elementary Path Semiring} 
\label{coq:def:min_app_non_distributive_dioid}
\end{listing}

Finally we defined and constructed all the stuff we want and all the properties we need to proof. Detailed proof could be found in my Coq file.

